package main

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
	"net/netip"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"syscall"
	"unsafe"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/davecgh/go-spew/spew"
	"github.com/google/gopacket/layers"
	"github.com/vishvananda/netns"
	"golang.org/x/sys/unix"
)

//go: generate go run github.com/cilium/ebpf/cmd/bpf2go -target bpfel -cc clang -cflags ${CFLAGS} -type event_t socket socket.c -- $CLANG_OS_FLAGS -I./bpf/

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -target amd64 socket socket.c -I/usr/include/x86_64-linux-gnu/

type dnsEventT struct {
	Netns     uint32
	SaddrV4   uint32
	DaddrV4   uint32
	Af        uint32
	Sport     uint16
	Dport     uint16
	DnsOff    uint16
	DnsEnd    uint16
	DnsLength uint32
	Proto     uint8
	Payload   [200]uint16
	// The 'data' field from C is omitted because it represents a pointer,
	// which is not directly usable in Go's context for this structure.
}

func main() {
	// stuff := uint16(27765)
	// fmt.Println("it is ", htons(stuff))
	// return
	// ids := getallcontainers()
	// fmt.Println(ids)
	// getpidandmntns("d0d65dcf9f19")
	// return
	objs := socketObjects{}
	if err := loadSocketObjects(&objs, &ebpf.CollectionOptions{}); err != nil {
		log.Fatalf("loading objects: %v", err)
	}
	defer objs.Close()

	sigChan := make(chan os.Signal, 1)
	// Notify sigChan on os.Interrupt (Ctrl+C)
	signal.Notify(sigChan, syscall.SIGINT)

	pid := uint32(os.Getpid())
	sock, err := OpenRawSock(pid)
	if err != nil {
		log.Fatalf("creating map: %s", err)
	}

	if err := syscall.SetsockoptInt(sock, syscall.SOL_SOCKET, unix.SO_ATTACH_BPF, objs.SimpleSocketHandler.FD()); err != nil {
		fmt.Errorf("attaching BPF program: %w", err)
	}

	log.Println("opened raw socket and inseted code..")

	rd, err := ringbuf.NewReader(objs.SocketEvents)
	// rd, err := perf.NewReader(objs.SocketEvents, 4096)
	if err != nil {
		log.Fatalf("opening ringbuf reader: %s", err)
	}
	defer rd.Close()

	// Close the reader when the process receives a signal, which will exit
	// the read loop.
	go func() {
		<-sigChan

		if err := rd.Close(); err != nil {
			log.Fatalf("closing ringbuf reader: %s", err)
		}
	}()

	log.Println("Waiting for events..")

	// bpfEvent is generated by bpf2go.
	for {
		var event dnsEventT

		record, err := rd.Read()
		if err != nil {

			if errors.Is(err, ringbuf.ErrClosed) {
				log.Println("Received signal, exiting..")
				return
			}

			log.Printf("reading from reader: %s", err)
			continue
		}

		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.BigEndian, &event); err != nil {
			log.Printf("parsing ringbuf event: %s", err)

		}

		fmt.Println("event is ", event)

		fmt.Println("--------------------")

		srcIP, ok := netip.AddrFromSlice(record.RawSample[4:8])
		if ok {
			fmt.Println("Source IP: ", srcIP.String()) // Expected: 255.255.255.252
		}

		dstIP, ok := netip.AddrFromSlice(record.RawSample[8:12])
		if ok {
			fmt.Println("Destination IP: ", dstIP.String()) // Expected: 75.75.75.120
		}
		SourcePort := binary.LittleEndian.Uint16(record.RawSample[16:18])
		DestPort := binary.LittleEndian.Uint16(record.RawSample[18:20])
		dnsoff := binary.BigEndian.Uint16(record.RawSample[20:22])
		dnslength := binary.BigEndian.Uint32(record.RawSample[22:28])

		fmt.Println("Source Port: ", SourcePort)    //
		fmt.Println("Destination Port: ", DestPort) //
		fmt.Println("DNSoff : ", dnsoff)            //
		fmt.Println("DNSlength : ", dnslength)      //
		fmt.Println("", string(record.RawSample[30:]))
		spew.Dump(record.RawSample[31:])
		fmt.Println("********************")
		fmt.Println("--------------------")
	}

}

func Uint16SliceFromBytes(bytes []byte) ([]uint16, bool) {
	if len(bytes)%2 != 0 { // Ensure that the byte slice length is even
		return nil, false
	}

	var uint16s []uint16
	for i := 0; i < len(bytes); i += 2 {
		if i+1 < len(bytes) {
			uint16s = append(uint16s, binary.BigEndian.Uint16(bytes[i:i+2]))
		}
	}
	return uint16s, true
}

func protocolToString(proto uint8) string {
	switch proto {
	case 6:
		return "TCP"
	case 17:
		return "UDP"
	default:
		return fmt.Sprintf("Unknown(%d)", proto)
	}
}

func OpenRawSock(pid uint32) (int, error) {

	if pid != 0 {
		HostProcFs := GetHostproc()
		// Lock the OS Thread so we don't accidentally switch namespaces
		runtime.LockOSThread()
		defer runtime.UnlockOSThread()

		// Save the current network namespace
		origns, _ := netns.Get()
		defer origns.Close()

		netnsHandle, err := GetFromPidWithAltProcfs(int(pid), HostProcFs)
		if err != nil {
			return -1, err
		}
		defer netnsHandle.Close()
		err = netns.Set(netnsHandle)
		if err != nil {
			return -1, err
		}

		// Switch back to the original namespace
		defer netns.Set(origns)
	}

	fmt.Println("pid is", pid)

	sock, err := syscall.Socket(syscall.AF_PACKET, syscall.SOCK_RAW, int(htons(syscall.ETH_P_ALL)))

	if err != nil {
		return -1, err
	}

	fmt.Println("sock is", sock)

	sll := syscall.SockaddrLinklayer{
		Ifindex:  0, // 0 matches any interface
		Protocol: htons(syscall.ETH_P_ALL),
	}
	if err := syscall.Bind(sock, &sll); err != nil {
		return -1, err
	}
	return sock, nil
}

func htons(i uint16) uint16 {
	b := make([]byte, 2)
	binary.BigEndian.PutUint16(b, i)
	return *(*uint16)(unsafe.Pointer(&b[0]))
}

func GetHostproc() string {
	// Initialize HostRoot and HostProcFs
	HostRoot := os.Getenv("HOST_ROOT")
	if HostRoot == "" {
		HostRoot = "/"
	}
	HostProcFs := filepath.Join(HostRoot, "/proc")
	return HostProcFs
}

func GetFromPidWithAltProcfs(pid int, procfs string) (netns.NsHandle, error) {
	return netns.GetFromPath(fmt.Sprintf("%s/%d/ns/net", procfs, pid))
}

// // DNSOff uint16, DNSEnd uint16,
func parseDNSPacket(rawSample []byte, doff int) {
	// The sample received is a concatenation of the dnsEventT structure and the packet bytes.
	// ev := (*dnsEventT)(unsafe.Pointer(&rawSample[0]))
	// bpfEvent := (*dnsEventT)(unsafe.Pointer(&rawSample[0]))
	// packetBytes := rawSample[unsafe.Sizeof(*bpfEvent):]

	// if len(packetBytes) < doff {
	// 	fmt.Println("packet too short")
	// 	return
	// }
	packetBytes := rawSample[doff:]
	dnsLayer := layers.DNS{}
	err := dnsLayer.DecodeFromBytes(packetBytes, nil)
	if err != nil {
		fmt.Println("decoding dns layer: %w", err)
		return
	}
	fmt.Println("question is ", dnsLayer.Questions)

	if len(dnsLayer.Questions) > 0 {
		question := dnsLayer.Questions[0]
		QType := question.Type.String()
		DNSName := string(question.Name) + "."
		fmt.Println("stuff is ", QType, " ", DNSName)
	}

	for _, answer := range dnsLayer.Answers {
		if answer.IP == nil {
			continue
		}
		fmt.Println(" --> ", answer.IP.String())
	}

}

// func parseDNSPacket(data []byte) {
// 	var result string
// 	offset := 0
// 	for offset < len(data) {
// 		length := int(data[offset])
// 		if length == 0 {
// 			result += ")"
// 			break // End of the domain name
// 		}
// 		if length >= 192 { // Handle DNS compression pointers
// 			// This is a pointer to a previously seen name part
// 			// Extract the offset from the next byte and then jump to that offset
// 			newOffset := int(data[offset+1])
// 			offset = newOffset - 192 // Adjust offset to the start of the domain part
// 			continue
// 		}
// 		if offset+length+1 > len(data) {
// 			fmt.Println("Error: Slice bounds out of range.")
// 			break
// 		}
// 		offset++ // Move past the length byte
// 		result += string(data[offset:offset+length]) + "."
// 		offset += length
// 	}
// 	fmt.Println("DNS Payload: ", result)
// }
